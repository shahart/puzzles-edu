package edu.generalpuzzle.main;

/**
 * Created by IntelliJ IDEA.
 * Date: 16/04/2009
 */
/*

COPYRIGHT 2003 Daniel Tebbutt

See comment at head of bedlamCanvas.java

*/

import java.lang.*;
import java.applet.*;
import java.util.*;
import java.awt.*;

public class Bedlam extends Applet
{

// Used for displaying solutions
private static long LOW16BITS=0xffff;

private static boolean initialized=false;
private static boolean init_complete=false;

private boolean stillWaiting;
private int mod1[],mod2[];

// A single 64-bit integer represents a 4x4x4 grid.
// If a bit is 1 then that space is full
// If a bit is 0 then that space is empty

// For every shape, every possible place and orientation it can be placed in
// Trial and error indicates that no shape has more than about 450 possible placements.
// These values are autogenerated at the start of the run.
private static long blocks[][];

// Blocks arranged by:
//    Whether they occupy a particular bit
//    Which shape they are a placement of
private static long bitordered[][][];

// Which bits to try to fill first.
// This is a simple configuration, which could be generated on the fly.
// Easier to change this way though.
private static long cornerfirst[] = {
0x10000000,
0x20000000,
0x40000000,
0x80000000,
0x01000000,
0x02000000,
0x04000000,
0x08000000,
0x00100000,
0x00200000,
0x00400000,
0x00800000,
0x00010000,
0x00020000,
0x00040000,
0x00080000,
0x00001000,
0x00002000,
0x00004000,
0x00008000,
0x00000100,
0x00000200,
0x00000400,
0x00000800,
0x00000010,
0x00000020,
0x00000040,
0x00000080,
0x00000001,
0x00000002,
0x00000004,
0x00000008,
0x0000000010000000,
0x0000000020000000,
0x0000000040000000,
0x0000000080000000,
0x0000000001000000,
0x0000000002000000,
0x0000000004000000,
0x0000000008000000,
0x0000000000100000,
0x0000000000200000,
0x0000000000400000,
0x0000000000800000,
0x0000000000010000,
0x0000000000020000,
0x0000000000040000,
0x0000000000080000,
0x0000000000001000,
0x0000000000002000,
0x0000000000004000,
0x0000000000008000,
0x0000000000000100,
0x0000000000000200,
0x0000000000000400,
0x0000000000000800,
0x0000000000000010,
0x0000000000000020,
0x0000000000000040,
0x0000000000000080,
0x0000000000000001,
0x0000000000000002,
0x0000000000000004,
0x0000000000000008
};

// For each bit and shape, how many of the placements are valid.  Must be between 0 and 99 inclusive.
private static int bitorderedsizes[][];

// For each shape, how many of the placements are valid.  Must be between 0 and 499 inclusive
private static int sizes[];

// Current set of moves.  Used to System.out.print out each solution
private int soln[];
private int progresssoln[];
private int blocksoln[];

private int counter=0;

// Index for each shape.
private static int shapefields[] = {
  0x0001,
  0x0002,
  0x0004,
  0x0008,
  0x0010,
  0x0020,
  0x0040,
  0x0080,
  0x0100,
  0x0200,
  0x0400,
  0x0800,
  0x1000
};

// How many solutions have been found.  All solutions should be unique
private static int solved=0;

// Text representation of a cube.  Used in autogeneration of block placings
private static char cube[][][];

// Text representation of each shape.  Used in autogeneration of block placings.
private static String stringShapes[][][] = {
  // BLUE
  {{"0  ","000"," 0 "},{"   ","   ","   "},{"   ","   ","   "}},
  {{" 1 ","   ","   "},{"111","1  ","   "},{"   ","   ","   "}},
  {{"   "," 2 "," 22"},{"   ","22 ","   "},{"   ","   ","   "}},
  {{"   ","   ","333"},{"   "," 3 "," 3 "},{"   ","   ","   "}},
  // RED
  {{" 4 ","444"," 4 "},{"   ","   ","   "},{"   ","   ","   "}},
  {{"5  ","   ","   "},{"5  ","55 "," 5 "},{"   ","   ","   "}},
  {{"   "," 6 ","   "},{"   "," 66","66 "},{"   ","   ","   "}},
  {{"7  ","   ","   "},{"77 ","7  ","7  "},{"   ","   ","   "}},
  // YELLOW
  {{"8  ","88 "," 88"},{"   ","   ","   "},{"   ","   ","   "}},
  {{"9  ","99 ","9  "},{"   ","9  ","   "},{"   ","   ","   "}},
  {{"a  ","   ","   "},{"a  ","a  ","aa "},{"   ","   ","   "}},
  {{"   ","   ","bb "},{"   "," b "," b "},{"   ","   ","   "}},
  {{"   ","   ","ccc"},{"   ","c  ","c  "},{"   ","   ","   "}}
};

private static char shapes[][][][];

// Place a shape in a particular point, in a particular orientation.
// If this is impossible, return false, else return true
// This is only used for the pre-processing step, so no need to be efficient.
private static boolean place(int x, // x co-ordinate.  Between -2 and 3
          int y, // y co-ordinate.  Between -2 and 3
          int z, // z co-ordinate.  Between -2 and 3
          int ori, // orientation.  Between 0 and 23
          int sh)  // shape index.  Between 0 and 12
{
  int a,b,c,sx=0,sy=0,sz=0,osx,osy,osz,dirs[][] = {
    {1,1,1,1},   //  For each orientation:
    {1,1,-1,4},  //    Whether we are moving in a positive direction along the x-axis
    {1,-1,1,4},  //    Whether we are moving in a positive direction along the y-axis
    {1,-1,-1,1}, //    Whether we are moving in a positive direction along the z-axis
    {-1,1,1,4},  //    Which shape axis matches which cube axis.
    {-1,1,-1,1},
    {-1,-1,1,1},
    {-1,-1,-1,4},
    {1,1,1,2},
    {1,1,-1,5},
    {1,-1,1,5},
    {1,-1,-1,2},
    {-1,1,1,5},
    {-1,1,-1,2},
    {-1,-1,1,2},
    {-1,-1,-1,5},
    {1,1,1,3},
    {1,1,-1,6},
    {1,-1,1,6},
    {1,-1,-1,3},
    {-1,1,1,6},
    {-1,1,-1,3},
    {-1,-1,1,3},
    {-1,-1,-1,6}
  };

  // Initialize the cube.
  // There are more efficient ways of doing this, but this is not time-critical code.
  for (b =0;b < 4;b++)
  {
    for (c = 0;c < 4;c++)
    {
      for (a = 0;a < 4;++a)
      {
        cube[b][c][a] = ' ';
      }
    }
  }

  // Let our orientation define our shape starting corner.
  if (dirs[ori][0] == -1)
    osx = 2;
  else
    osx = 0;

  if (dirs[ori][1] == -1)
    osy = 2;
  else
    osy = 0;

  if (dirs[ori][2] == -1)
    osz = 2;
  else
    osz = 0;

  // Initialize the appropriate shape counter
  if (dirs[ori][3] == 1 || dirs[ori][3] == 4)
    sx = osx;
  else if (dirs[ori][3] == 2 || dirs[ori][3] == 5)
    sy = osy;
  else
    sz = osz;

  for (a = 0;a < 3;++a)
  {
    // Initialize the appropriate shape counter
    if (dirs[ori][3] == 3 || dirs[ori][3] == 5)
      sx = osx;
    else if (dirs[ori][3] == 1 || dirs[ori][3] == 6)
      sy = osy;
    else
      sz = osz;

    for (b = 0;b < 3;++b)
    {
      // Initialize the appropriate shape counter
      if (dirs[ori][3] == 2 || dirs[ori][3] == 6)
        sx = osx;
      else if (dirs[ori][3] == 3 || dirs[ori][3] == 4)
        sy = osy;
      else
        sz = osz;

      for (c = 0;c < 3;++c)
      {
        // If we should be placing a cube here, check it's allowed
        if (shapes[sh][sx][sy][sz] != ' ')
        {
          // 3 separate tests for clarity
          if ((x+a) < 0 || (x+a) > 3)
            return(false);
          if ((y+b) < 0 || (y+b) > 3)
            return(false);
          if ((z+c) < 0 || (z+c) > 3)
            return(false);

          // Check for internal error
          if (cube[x+a][y+b][z+c] != ' ')
          {
            System.out.print("Internal Error");
            System.exit(0);
          }

          // fill in the cube
          cube[x+a][y+b][z+c] = shapes[sh][sx][sy][sz];
        }

        // Increment appropriate shape counter
        if (dirs[ori][3] == 2 || dirs[ori][3] == 6)
          sx += dirs[ori][0];
        else if (dirs[ori][3] == 3 || dirs[ori][3] == 4)
          sy += dirs[ori][1];
        else
          sz += dirs[ori][2];
      }
      // Increment appropriate shape counter
      if (dirs[ori][3] == 3 || dirs[ori][3] == 5)
        sx += dirs[ori][0];
      else if (dirs[ori][3] == 1 || dirs[ori][3] == 6)
        sy += dirs[ori][1];
      else
        sz += dirs[ori][2];
    }
    // Increment appropriate shape counter
    if (dirs[ori][3] == 1 || dirs[ori][3] == 4)
      sx += dirs[ori][0];
    else if (dirs[ori][3] == 2 || dirs[ori][3] == 5)
      sy += dirs[ori][1];
    else
      sz += dirs[ori][2];
  }

// If we've got this far, we must have succeeded.
return(true);
}

// Convert a 4x4x4 char array into an long
// Used in pre-processing code, so no need to be efficient.
private static long calculate()
{
  int a,b,c;
  long s;
  long temp;

  s = 0;
  for (a = 0;a < 4;++a)
  {
    for (b = 0;b < 4;++b)
    {
      for (c = 0;c < 4;++c)
      {
        if (cube[a][b][c] != ' ')
        {
          temp = 1;
          temp = temp << a * 8;
          temp = temp << a * 8;
          temp = temp << ((b*4) + c);
          s += temp;
        }
      }
    }
  }
  return(s);
}

// For every shape, find every possible unique placement and orientation
// Restrict those for the first shape, since this will be first one we place, and therefore
// we can eliminate any symmetrical findings.
private static void autogenerate()
{
  int a,b,c,d,e,f;
  boolean valid=true;
  int placed=0;

  for (a = 0;a < 13;++a)
  {
    for (b = 0;b < (a == 0 ? 1 : 24);++b)
    {
      for (c = -2;c < 4;++c)
      {
        for (d = -2;d < 4;++d)
        {
          for (e = -2;e < 4;++e)
          {
            // Place the block if we can
            if (place(c,d,e,b,a))
            {
              // Convert to long
              blocks[a][placed] = calculate();
              valid=true;
              // Check for duplicates
              for (f = 0;f < placed;++f)
              {
                if (blocks[a][f] == blocks[a][placed])
                {
                  valid = false;
                }
              }
              // See if this was valid
              if (valid)
              {
               ++placed;
              }
            }
          }
        }
      }
    }

    sizes[a]=placed;
    placed=0;
  }

}

// Arrange the blocks into the bitordered array
private static void autoindex()
{
  long bitfield,antifield=0;
  int a,b,c,count,total;

  total = 0;
  for (a = 0;a < 64;++a)
  {
    count = 0;
    bitfield = cornerfirst[a];
    for (b = 0;b < 13;++b)
    {
      for (c = 0;c < sizes[b];++c)
      {
        if (((blocks[b][c] & bitfield) != 0) &&
            ((blocks[b][c] & antifield) == 0))
        {
          bitordered[a][b][count] = blocks[b][c];
          ++count;
        }
      }
      bitorderedsizes[a][b] = count;
      total += count;
      count = 0;
    }
    antifield += bitfield;
  }

}

public void stop()
{

}

public void start()
{
}

public void init()
{
int a,b,c;
Panel p1,p2,p3;

mod1 = new int[13];
mod2 = new int[13];
soln = new int[13];
progresssoln = new int[13];
blocksoln = new int[13];

if (!initialized)
{
  initialized=true;
  blocks = new long[13][500];
  bitordered = new long[64][13][100];
  bitorderedsizes = new int[64][13];
  sizes = new int[13];
  cube = new char[4][4][4];
  shapes = new char[13][3][3][3];

  for (a = 0;a < 13;++a)
  {
    for (b = 0;b < 3;++b)
    {
      for (c = 0;c < 3;++c)
      {
         shapes[a][b][c] = stringShapes[a][b][c].toCharArray();
      }

    }

  }

  for (a = 0;a < 32;++a)
  {
    cornerfirst[a] = cornerfirst[a] << 32;
  }

  // Auto-generate the shape configurations
  autogenerate();

  autoindex();
  init_complete = true;
}
else
{
  while (!init_complete)
  {
    try
    {
      Thread.sleep( 100 );
    }
    catch ( InterruptedException e )
    {
    }
  }
}

  System.out.println("Setup");


  setBackground(Color.white);


  p2 = new Panel(new GridLayout(1,3,6,0));
  p2.setSize(300,20);
  p3 = new Panel(new GridLayout(4,1,0,6));
  p3.setSize(300,80);
  p3.add(p2);
  add(p3);

    getRandomSoln();


}

private void solveOnceBackwards(int depth,
                                       long state,
                                       int shapesused,
                                       int bitsofar)
{
  long bitcheck;
  int a,b,c,bitcount,max,cmod,bmod;

  // If depth=13 then we're done.
  if (depth == 13)
  {
    stillWaiting=false;
    return;
  }

  bitcount=bitsofar;
  bitcheck = cornerfirst[bitcount];
  while ((state & bitcheck) != 0)
  {
    ++bitcount;
    bitcheck = cornerfirst[bitcount];
  }

  // Try every way of fitting in the next block
  if (mod1[depth] == -1)
  {
    mod1[depth] = 12;
  }
  for (c = mod1[depth]%13;(c >= 0) && stillWaiting;--c)
  {
    cmod = c;
    if ((shapefields[cmod] & shapesused) == 0 && bitorderedsizes[bitcount][cmod] > 0)
    {
      max = bitorderedsizes[bitcount][cmod];
      if (mod2[depth] == -1)
        mod2[depth] = bitorderedsizes[bitcount][cmod]-1;
      for (b = mod2[depth]%bitorderedsizes[bitcount][cmod];(b >= 0) & stillWaiting;--b)
      {
        // If this test passes, then we can fit the block in
        bmod = b;
        if ((state & bitordered[bitcount][cmod][bmod]) == 0)
        {
          soln[depth]=bmod;
          progresssoln[depth]=bitcount;
          blocksoln[depth] = cmod;
          solveOnceBackwards(depth+1,
                             state+bitordered[bitcount][cmod][bmod],
                             shapesused+shapefields[cmod],
                             bitcount);
        }
      }
    }
    mod2[depth] = -1;
  }
  mod1[depth] = -1;

  if (depth==0 && stillWaiting)
  {
    solveOnceBackwards(0,0,0,0);
  }

}

private void solveOnce(int depth,
                              long state,
                              int shapesused,
                              int bitsofar)
{
  long bitcheck;
  int a,b,c,bitcount,max,cmod,bmod;

  ++counter;

  // If depth=13 then we're done.
  if (depth == 13)
  {
    stillWaiting=false;
    return;
  }

  bitcount=bitsofar;
  bitcheck = cornerfirst[bitcount];
  while ((state & bitcheck) != 0)
  {
    ++bitcount;
    bitcheck = cornerfirst[bitcount];
  }

  // Try every way of fitting in the next block
  for (c = mod1[depth]%13;(c < 13) && stillWaiting;++c)
  {
    cmod = c;
    if ((shapefields[cmod] & shapesused) == 0 && bitorderedsizes[bitcount][cmod] > 0)
    {
      max = bitorderedsizes[bitcount][cmod];
      for (b = mod2[depth]%bitorderedsizes[bitcount][cmod];(b < max) & stillWaiting;++b)
      {
        // If this test passes, then we can fit the block in
        bmod = b;
        if ((state & bitordered[bitcount][cmod][bmod]) == 0)
        {
          soln[depth]=bmod;
          progresssoln[depth]=bitcount;
          blocksoln[depth] = cmod;
          solveOnce(depth+1,
                     state+bitordered[bitcount][cmod][bmod],
                     shapesused+shapefields[cmod],
                     bitcount);
        }
      }
    }
    mod2[depth]=0;
  }
  mod1[depth] = 0;

  if (depth==0 && stillWaiting)
  {
    solveOnce(0,0,0,0);
  }

}

public long[][] getRandomSoln()
{
Random r;
long solnn[][];
int a;

solnn = new long[2][13];

stillWaiting=true;

r = new Random();

r.setSeed(System.currentTimeMillis());

for (a = 0;a < 13;++a)
{
  mod1[a] = r.nextInt();
  if (mod1[a] < 0)
    mod1[a] = 0 - mod1[a];
  mod2[a] = r.nextInt();
  if (mod2[a] < 0)
    mod2[a] = 0 - mod2[a];
}

solveOnce(0,0,0,0);
for (a = 0;a < 13;++a)
{
  solnn[0][a] = bitordered[progresssoln[a]][blocksoln[a]][(int)(soln[a])];
  solnn[1][a] = (long)(blocksoln[a]);
}

return solnn;
}

public long[][] getPreviousSoln()
{
long solnn[][];
int a,b;

solnn = new long[2][13];

stillWaiting=true;

for (a = 0;a < 13;++a)
{
  mod1[a] = blocksoln[a];
  mod2[a] = soln[a];
}

--mod2[12];
b=12;
while (mod2[b] < 0)
{
  mod2[b] = bitorderedsizes[progresssoln[b]][blocksoln[b]] - 1;
  --mod1[b];
  if (mod1[b] < 0)
  {
    mod1[b] = 12;
    --b;
    --mod2[b];
  }
}

solveOnceBackwards(0,0,0,0);
for (a = 0;a < 13;++a)
{
  solnn[0][a] = bitordered[progresssoln[a]][blocksoln[a]][(int)(soln[a])];
  solnn[1][a] = (long)(blocksoln[a]);
}


return solnn;
}

public long[][] getNextSoln()
{
long solnn[][];
int a,b;

solnn = new long[2][13];

stillWaiting=true;

for (a = 0;a < 13;++a)
{
  mod1[a] = blocksoln[a];
  mod2[a] = soln[a];
}

++mod2[12];
b=12;
while (mod2[b] == bitorderedsizes[progresssoln[b]][blocksoln[b]])
{
  mod2[b]=0;
  ++mod1[b];
  if (mod1[b] == 13)
  {
    mod1[b] = 0;
    --b;
    ++mod2[b];
  }
}

solveOnce(0,0,0,0);
for (a = 0;a < 13;++a)
{
  solnn[0][a] = bitordered[progresssoln[a]][blocksoln[a]][(int)(soln[a])];
  solnn[1][a] = (long)(blocksoln[a]);
}

return solnn;
}

}
